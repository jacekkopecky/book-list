{"mappings":"A,C,KEAO,IAAI,EAAW,EAAE,CACb,EAAU,GAInB,EDJe,CAAC,cAAc,wBAAwB,gBAAgB,uCAAuC,sCAAsC,YAAY,CCK/J,EDJc,4B,I,E,C,EGAhB,EAAiB,OAAO,MAAM,CAAC,CAC7B,MAAO,OAAO,MAAM,CAAC,CACnB,SAAU,mCACV,OAAQ,oCACR,SAAU,gCACV,gBAAiB,OACnB,GACA,UAAW,8EACX,WAAY,6BACZ,QAAS,yBACX,GDLA,IAAM,EAAY,EAElB,eAAe,IACb,QAAQ,GAAG,CAAC,CAAE,QAAA,CAAQ,GACtB,IAAM,EAAQ,IAAI,EAAU,eAAe,CAC3C,IAAK,IAAM,KAAQ,EACjB,QAAQ,GAAG,CAAC,eAAgB,GAE9B,IAAM,EAAQ,MAAM,OAAO,IAAI,CAAC,EAChC,OAAM,EAAM,MAAM,CAAC,EACrB,CAEA,eAAe,IACb,IAAM,EAAO,MAAM,OAAO,IAAI,EAC9B,OAAM,QAAQ,GAAG,CACf,EAAK,GAAG,CAAC,AAAC,GACR,AAAI,IAAQ,GACV,QAAQ,GAAG,CAAC,6BAA8B,GACnC,OAAO,MAAM,CAAC,IAErB,KAAA,GAIR,CAEA,eAAe,EAAW,CAAgB,EACxC,GAAI,AAAmB,QAAnB,EAAQ,MAAM,CAAY,K,EAE5B,GAAI,EAAQ,GAAG,CAAC,UAAU,CAAC,A,C,C,EAAA,I,E,U,C,E,O,C,C,EAAO,SAAS,EACzC,GAAI,CACF,IAAM,EAAW,MAAM,MAAM,GACvB,EAAQ,MAAM,OAAO,IAAI,CAAC,GAEhC,OADA,MAAM,EAAM,GAAG,CAAC,EAAS,EAAS,KAAK,IAChC,CACT,CAAE,MAAO,EAAG,CACV,IAAM,EAAQ,MAAM,OAAO,KAAK,CAAC,EAAQ,GAAG,EAC5C,GAAI,EAAO,OAAO,CACb,OAAM,CACb,CAIF,IAAM,EAAiB,MAAM,OAAO,KAAK,CAAC,GAC1C,GAAI,EAAgB,OAAO,EAG3B,GAAI,EAAQ,GAAG,CAAC,UAAU,CAAC,KAAK,QAAQ,CAAC,MAAM,EAAG,CAChD,IAAM,EAAkB,MAAM,OAAO,KAAK,CAAC,IAAI,IAAI,cAAe,KAAK,QAAQ,CAAC,MAAM,GACtF,GAAI,EAAiB,OAAO,CAC9B,CACF,CAEA,OAAO,MAAM,EACf,CAWA,KAAK,gBAAgB,CAAC,UAAW,AAAC,GAAM,EAAE,SAAS,CAAC,MACpD,KAAK,gBAAgB,CAAC,WAAY,AAAC,GAAM,EAAE,SAAS,CAAC,MAErD,KAAK,gBAAgB,CAAC,QAAS,AAAC,IAC9B,EAAM,WAAW,CAAC,EAAW,EAAM,OAAO,EAC5C,GAEA,KAAK,gBAAgB,CAAC,OAAQ,AAAC,GAAM,EAAE,SAAS,CAZvC,KAAK,YAAY,CAAC,gBAAgB,CAAC,oBAAqB,CAC7D,KAAM,8CACR,I,C","sources":["<anon>","node_modules/@parcel/service-worker/runtime-bea5f520f3c6fca7.js","node_modules/@parcel/service-worker/service-worker.js","src/service-worker.ts","server/config.js"],"sourcesContent":["(() => {\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $3829b85dc3d008cb$exports = {};\nlet $2039b88b1be162b9$export$e538f94cc8cf4db8 = [];\nlet $2039b88b1be162b9$export$83d89fbfd8236492 = \"\";\nfunction $2039b88b1be162b9$export$c208e1278d7beb2(m, v) {\n    $2039b88b1be162b9$export$e538f94cc8cf4db8 = m;\n    $2039b88b1be162b9$export$83d89fbfd8236492 = v;\n}\n\n\nconst $3829b85dc3d008cb$var$manifest = [\n    \"/index.html\",\n    \"/manifest.webmanifest\",\n    \"/img/icon.svg\",\n    \"/index.d539dbac.css\",\n    \"/index.3a8e7baf.js\",\n    \"/404.html\"\n];\nconst $3829b85dc3d008cb$var$version = \"dd08ddaa\";\n(0, $2039b88b1be162b9$export$c208e1278d7beb2)($3829b85dc3d008cb$var$manifest, $3829b85dc3d008cb$var$version);\n\nvar $0c81e46209371114$exports = {};\n/// <reference lib=\"webworker\" />\n\nvar $6c9cd707d3b83384$exports = {};\n// Auth0 settings\n$6c9cd707d3b83384$exports = Object.freeze({\n    auth0: Object.freeze({\n        clientId: \"N9qSgGHtOj1eLg5fDwiaeO9yu9NEJjQq\",\n        domain: \"dev-bl7cntsbvqqv2sju.uk.auth0.com\",\n        audience: \"https://books.jacek.cz/api-v2\",\n        tokenSigningAlg: \"RS256\"\n    }),\n    serverURL: \"https://europe-west2-book-list-309615.cloudfunctions.net/bookListAPIv2/api/\",\n    serverURL2: \"http://localhost:8082/api/\",\n    website: \"https://books.jacek.cz/\"\n});\n\n\nconst $0c81e46209371114$var$cacheName = (0, $2039b88b1be162b9$export$83d89fbfd8236492);\nasync function $0c81e46209371114$var$install() {\n    console.log({\n        version: $2039b88b1be162b9$export$83d89fbfd8236492\n    });\n    const files = [\n        ...(0, $2039b88b1be162b9$export$e538f94cc8cf4db8),\n        \"/version.txt\"\n    ];\n    for (const path of files)console.log(\"adding cache\", path);\n    const cache = await caches.open($0c81e46209371114$var$cacheName);\n    await cache.addAll(files);\n}\nasync function $0c81e46209371114$var$activate() {\n    const keys = await caches.keys();\n    await Promise.all(keys.map((key)=>{\n        if (key !== $0c81e46209371114$var$cacheName) {\n            console.log(\"deleting cache for version\", key);\n            return caches.delete(key);\n        } else return undefined;\n    }));\n}\nasync function $0c81e46209371114$var$cacheFirst(request) {\n    if (request.method === \"GET\") {\n        // network-first cache API requests for later use if we go offline\n        if (request.url.startsWith((0, (/*@__PURE__*/$parcel$interopDefault($6c9cd707d3b83384$exports))).serverURL)) try {\n            const response = await fetch(request);\n            const cache = await caches.open($0c81e46209371114$var$cacheName);\n            await cache.put(request, response.clone());\n            return response;\n        } catch (e) {\n            const match = await caches.match(request.url);\n            if (match) return match;\n            else throw e;\n        }\n        // cache the rest of the files\n        const directCacheHit = await caches.match(request);\n        if (directCacheHit) return directCacheHit;\n        // respond with index.html for anything local but not cached\n        if (request.url.startsWith(self.location.origin)) {\n            const defaultCacheHit = await caches.match(new URL(\"/index.html\", self.location.origin));\n            if (defaultCacheHit) return defaultCacheHit;\n        }\n    }\n    return fetch(request);\n}\nfunction $0c81e46209371114$var$reloadBooks() {\n    // optimally we could reload the books, but we'd need to override the JWT auth\n    // for now, just ask the user to refresh\n    return self.registration.showNotification(\"Bananas for Books\", {\n        body: \"Your books have been updated, please refresh\"\n    });\n}\nself.addEventListener(\"install\", (e)=>e.waitUntil($0c81e46209371114$var$install()));\nself.addEventListener(\"activate\", (e)=>e.waitUntil($0c81e46209371114$var$activate()));\nself.addEventListener(\"fetch\", (event)=>{\n    event.respondWith($0c81e46209371114$var$cacheFirst(event.request));\n});\nself.addEventListener(\"push\", (e)=>e.waitUntil($0c81e46209371114$var$reloadBooks()));\n\n})();\n//# sourceMappingURL=service-worker.js.map\n","import {_register} from '@parcel/service-worker';\nconst manifest = [\"/index.html\",\"/manifest.webmanifest\",\"/img/icon.svg\",\"/index.d539dbac.css\",\"/index.3a8e7baf.js\",\"/404.html\"];\nconst version = \"dd08ddaa\";\n_register(manifest, version);\n","export let manifest = [];\nexport let version = '';\n\n// Called by the runtime.\nexport function _register(m, v) {\n  manifest = m;\n  version = v;\n}\n","/// <reference lib=\"webworker\" />\n\nimport { manifest, version } from '@parcel/service-worker';\nimport config from '../server/config';\n\ndeclare let self: ServiceWorkerGlobalScope;\n\nconst cacheName = version;\n\nasync function install() {\n  console.log({ version });\n  const files = [...manifest, '/version.txt'];\n  for (const path of files) {\n    console.log('adding cache', path);\n  }\n  const cache = await caches.open(cacheName);\n  await cache.addAll(files);\n}\n\nasync function activate() {\n  const keys = await caches.keys();\n  await Promise.all(\n    keys.map((key) => {\n      if (key !== cacheName) {\n        console.log('deleting cache for version', key);\n        return caches.delete(key);\n      } else {\n        return undefined;\n      }\n    }),\n  );\n}\n\nasync function cacheFirst(request: Request) {\n  if (request.method === 'GET') {\n    // network-first cache API requests for later use if we go offline\n    if (request.url.startsWith(config.serverURL)) {\n      try {\n        const response = await fetch(request);\n        const cache = await caches.open(cacheName);\n        await cache.put(request, response.clone());\n        return response;\n      } catch (e) {\n        const match = await caches.match(request.url);\n        if (match) return match;\n        else throw e;\n      }\n    }\n\n    // cache the rest of the files\n    const directCacheHit = await caches.match(request);\n    if (directCacheHit) return directCacheHit;\n\n    // respond with index.html for anything local but not cached\n    if (request.url.startsWith(self.location.origin)) {\n      const defaultCacheHit = await caches.match(new URL('/index.html', self.location.origin));\n      if (defaultCacheHit) return defaultCacheHit;\n    }\n  }\n\n  return fetch(request);\n}\n\nfunction reloadBooks() {\n  // optimally we could reload the books, but we'd need to override the JWT auth\n  // for now, just ask the user to refresh\n\n  return self.registration.showNotification('Bananas for Books', {\n    body: 'Your books have been updated, please refresh',\n  });\n}\n\nself.addEventListener('install', (e) => e.waitUntil(install()));\nself.addEventListener('activate', (e) => e.waitUntil(activate()));\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(cacheFirst(event.request));\n});\n\nself.addEventListener('push', (e) => e.waitUntil(reloadBooks()));\n","// Auth0 settings\n\nmodule.exports = Object.freeze({\n  auth0: Object.freeze({\n    clientId: 'N9qSgGHtOj1eLg5fDwiaeO9yu9NEJjQq',\n    domain: 'dev-bl7cntsbvqqv2sju.uk.auth0.com',\n    audience: 'https://books.jacek.cz/api-v2',\n    tokenSigningAlg: 'RS256',\n  }),\n  serverURL: 'https://europe-west2-book-list-309615.cloudfunctions.net/bookListAPIv2/api/',\n  serverURL2: 'http://localhost:8082/api/',\n  website: 'https://books.jacek.cz/',\n});\n"],"names":["$2039b88b1be162b9$export$e538f94cc8cf4db8","$2039b88b1be162b9$export$83d89fbfd8236492","$6c9cd707d3b83384$exports","Object","freeze","auth0","clientId","domain","audience","tokenSigningAlg","serverURL","serverURL2","website","$0c81e46209371114$var$cacheName","$0c81e46209371114$var$install","console","log","version","files","path","cache","caches","open","addAll","$0c81e46209371114$var$activate","keys","Promise","all","map","key","delete","$0c81e46209371114$var$cacheFirst","request","method","a","url","startsWith","__esModule","default","response","fetch","put","clone","e","match","directCacheHit","self","location","origin","defaultCacheHit","URL","addEventListener","waitUntil","event","respondWith","registration","showNotification","body"],"version":3,"file":"service-worker.js.map"}